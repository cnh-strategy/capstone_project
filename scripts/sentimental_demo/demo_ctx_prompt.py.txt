# scripts/sentimental_demo/demo_ctx_prompt.py
import json
import argparse
from pathlib import Path
import sys, os

# 프로젝트 루트 import 경로
sys.path.append(os.path.abspath("."))

# ✅ main 브랜치용: debate_ver3_v3 → agents
from agents.sentimental_agent import SentimentalAgent

ART = Path("artifacts")
ART.mkdir(exist_ok=True)


def build_agent(agent_name: str, ticker: str):
    """
    단일 파일 내에서는 SentimentalAgent만 사용하지만,
    --agent 인자를 받아 확장 가능하게 구성.
    """
    name = (agent_name or "SentimentalAgent").strip()
    if name == "SentimentalAgent":
        return SentimentalAgent(ticker=ticker)
    raise ValueError(f"Unknown agent: {name}")


def load_ctx(ticker: str, agent_name: str):
    ag = build_agent(agent_name, ticker=ticker)
    prev = ag.preview_opinion_ctx()
    ctx  = prev.get("ctx_preview") or {}
    sysm = prev.get("system_msg", "")
    usrm = prev.get("user_msg", "")
    return ctx, sysm, usrm


def render_ctx_opinion(ctx: dict) -> str:
    snap = ctx.get("snapshot") or {}
    pred = (ctx.get("prediction") or {})
    unct = pred.get("uncertainty") or {}
    pf   = ctx.get("price_features")  or {}
    vf   = ctx.get("volume_features") or {}
    nf   = ctx.get("news_features")   or {}
    rf   = ctx.get("regime_features") or {}

    last_price   = snap.get("last_price")
    pred_close   = pred.get("pred_close")
    pred_return  = pred.get("pred_return")
    conf         = pred.get("confidence")
    std          = unct.get("std")
    prob_up      = pred.get("calibrated_prob_up")

    trend_7d       = pf.get("trend_7d")
    z20            = pf.get("zscore_close_20")
    rv20           = pf.get("rolling_vol_20")
    breakout_20    = pf.get("breakout_20")
    drawdown_20    = pf.get("drawdown_20")
    vol_z20        = vf.get("vol_zscore_20")
    turnover_rate  = vf.get("turnover_rate")
    volume_spike   = vf.get("volume_spike")

    news_today     = nf.get("today")
    news_trend_7d  = nf.get("trend_7d")
    news_vol_7d    = nf.get("vol_7d")
    news_shock_z   = nf.get("shock_z")
    news_c1        = nf.get("news_count_1d")
    news_c7        = nf.get("news_count_7d")

    regime   = rf.get("market_regime")
    sector_m = rf.get("sector_momentum")
    vix_bkt  = rf.get("vix_bucket")

    def fmt(v, nd=4):
        if v is None: return "N/A"
        try:
            if isinstance(v, bool): return "True" if v else "False"
            return f"{float(v):.{nd}f}"
        except Exception:
            return str(v)

    sec1 = (
        f"1. 기술적 분석 측면에서 최근 7일 추세(trend_7d)는 {fmt(trend_7d,4)}이며, "
        f"20일 Z-점수(zscore_close_20)는 {fmt(z20,2)}로 해석됩니다. "
        f"변동성(rolling_vol_20)은 {fmt(rv20,4)} 수준이고, 20일 돌파 여부(breakout_20)는 {fmt(breakout_20)}입니다. "
        f"드로다운(20일 기준)은 {fmt(drawdown_20,4)}입니다. 거래량 특성은 z-score {fmt(vol_z20,2)}, "
        f"turnover_rate {fmt(turnover_rate,3)}이며, 급등 여부(volume_spike)는 {fmt(volume_spike)}로 관찰됩니다."
    )

    sec2 = (
        "2. 거시경제 및 레짐 관점에서는 "
        f"시장 체제(market_regime)={regime if regime is not None else 'N/A'}, "
        f"섹터 모멘텀(sector_momentum)={sector_m if sector_m is not None else 'N/A'}, "
        f"변동성 구간(VIX bucket)={vix_bkt if vix_bkt is not None else 'N/A'}로 파악됩니다. "
        "레짐 신호가 약하거나 결측이면 단기 판단에서 기술·심리 요인의 비중이 커집니다."
    )

    inter_clauses = []
    if news_shock_z is not None and news_shock_z >= 1.5:
        inter_clauses.append("뉴스 쇼크가 커 단기 과잉반응 가능성이 존재합니다")
    if z20 is not None and abs(z20) >= 1.5:
        inter_clauses.append("가격이 단기 평균 대비 크게 이탈하여 되돌림/가속 가능성이 큽니다")
    if volume_spike:
        inter_clauses.append("수급 과열 신호로 변동성 확대에 유의해야 합니다")
    if rv20 is not None and rv20 >= 0.03:
        inter_clauses.append("변동성이 높은 구간이라 신뢰도 하락 요인이 됩니다")
    if not inter_clauses:
        inter_clauses.append("특이 상호작용 신호는 제한적입니다")

    sec4 = "4. 변수 간 상호작용을 보면, " + " · ".join(inter_clauses) + "."

    dir_txt = "상승" if (pred_return or 0) > 0 else "하락" if (pred_return or 0) < 0 else "보합"
    sec5 = (
        "5. 종합적으로 볼 때, "
        f"현재가 {fmt(last_price,2)}, 예측 종가 {fmt(pred_close,2)}로 "
        f"{dir_txt} 가능성이 시사됩니다(pred_return={fmt(pred_return,4)}, "
        f"confidence={fmt(conf,3)}, std={fmt(std,3)}, prob_up={fmt(prob_up,3)}). "
        "다만 상기 기술·심리·레짐 요인을 고려하여 포지션 크기와 손절/청산 기준을 보수적으로 운영하는 것을 권고합니다."
    )

    return "\n".join([sec1, sec2, sec4, sec5])


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--ticker", type=str, help="단일 티커")
    parser.add_argument("--tickers", nargs="+", help="티커 리스트")
    parser.add_argument("--agent", type=str, default=_AgentClass.__name__, help="Agent class name")
    parser.add_argument("--save-ab", action="store_true", help="간단 비교 CSV 저장(커버리지)")
    return parser.parse_args()


def normalize_tickers(args) -> list:
    if args.tickers and args.ticker:
        return list(dict.fromkeys([args.ticker] + args.tickers))
    if args.tickers:
        return args.tickers
    if args.ticker:
        return [args.ticker]
    return ["TSLA", "AAPL"]


def coverage_from_rendered(opinion_text: str, ctx: dict):
    keys = set()
    for sec in ("price_features", "volume_features", "news_features", "regime_features"):
        keys |= set((ctx.get(sec) or {}).keys())
    keys |= {"pred_return", "calibrated_prob_up", "pred_close", "confidence"}

    if not opinion_text:
        return 0.0

    hit = 0
    for k in keys:
        if k in opinion_text:
            hit += 1
    return round(hit / max(1, len(keys)), 3)


def main():
    args = parse_args()
    tickers = normalize_tickers(args)

    ART = Path("artifacts")
    ART.mkdir(exist_ok=True)

    rows = []
    for tk in tickers:
        ctx, sysm, usrm = load_ctx(tk, agent_name=args.agent)

        nf = ctx.get("news_features", {}) or {}
        vf = ctx.get("volume_features", {}) or {}
        surprise_proxy = (nf.get("shock_z") is not None and nf.get("shock_z") >= 1.5) or bool(vf.get("volume_spike"))
        print(f"[VALID] surprise_proxy? {surprise_proxy}  (shock_z={nf.get('shock_z')}, volume_spike={vf.get('volume_spike')})")

        pred = ctx.get("prediction", {}) or {}
        ba = {
            "last_price": (ctx.get("snapshot", {}) or {}).get("last_price"),
            "pred_close": pred.get("pred_close"),
            "pred_return": pred.get("pred_return"),
            "direction_delta": ("UP" if (pred.get("pred_return") or 0) > 0
                                else "DOWN" if (pred.get("pred_return") or 0) < 0 else "FLAT"),
            "prob_up": pred.get("calibrated_prob_up"),
        }
        (ART / f"before_after_{ctx.get('ticker')}_v3.json").write_text(
            json.dumps(ba, ensure_ascii=False, indent=2), encoding="utf-8"
        )
        print("[VALID] before_after:", ba)

        opinion_text = render_ctx_opinion(ctx)

        print("\n=== OPINION (ctx-based, numbered) ===")
        print(opinion_text)

        (ART / f"ctx_preview_{tk}_v3.json").write_text(json.dumps(ctx, ensure_ascii=False, indent=2), encoding="utf-8")
        (ART / f"opinion_{tk}_v3.txt").write_text(opinion_text, encoding="utf-8")
        (ART / f"prompt_{tk}_system_v3.txt").write_text(sysm, encoding="utf-8")
        (ART / f"prompt_{tk}_user_v3.txt").write_text(usrm, encoding="utf-8")

        cov = coverage_from_rendered(opinion_text, ctx)
        rows.append({"ticker": tk, "coverage": cov, "tokens": len(opinion_text)})

    if args.save_ab:
        lines = ["ticker,coverage,tokens\n"] + [
            f"{r['ticker']},{r['coverage']},{r['tokens']}\n" for r in rows
        ]
        (ART / "ab_compare_v3.csv").write_text("".join(lines), encoding="utf-8")


if __name__ == "__main__":
    main()
